<head>
    <style>
    body { background-color: #333; }

    #table {
        float: left;
        background-color: #633;
        border-radius: 20px;
        margin: 1% 1%;
        padding: 10px;
        width: 70%;
    }

    #indicator {
        position: fixed;
        top: 30px; right: 5%;
        background-color: #222;
        width: 100px; height: 100px;
        border-radius: 50px;
    }
    #indicator.good { background-color: #2f2; }
    #indicator.bad  { background-color: #f22; }

    #controller {
        position: fixed;
        top: 150px; right: 5%;
        background-color: #833;
        width: 15%;
        padding: 20px;
        border-radius: 20px;

        line-height: 30px;
        font-size: 20px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .card {
        user-select: none;
        vertical-align: top;
        display: inline-block;
        background-color: #eee;
        border-radius: 18px;
        width: 100px;
        height: 140px;
        padding: 10px;
        margin: 10px;
        line-height: 40px;
    }
    .smol .card {
        width: 50px; height: 50px;
        padding: 5px; margin: 5px;
        line-height: 20px;
    }
    .card > div {
        margin-top: 47px;
        margin-left: 25px;
        color: #444;
        font-weight: bolder;
        font-size: 80px;
        font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
    }
    .smol .card > div {
        margin-top: 14px; margin-left: 12px; font-size: 40px;
    }
    .card.selected { margin-top: 20px; margin-bottom: 0px; background-color: #cbd }
    .smol .card.selected { margin-top: 10px }
    .card.hint     { margin-top: 5px; margin-bottom: 15px; background-color: #ffd880; border-color: red; }
    .smol .card.hint { margin-top: 2px; margin-bottom: 8px }

    /*********** COLOURS ***********/
    .card.red > div   { color: #a22; }
    .card.green > div { color: #2a2; }
    .card.blue > div  { color: #22a; }
    .card.yellow > div  { color: #ca6; }

    /*********** EFFECTS ***********/
    .card.line > div { -webkit-text-stroke: 2px #222; }
    .card.shad > div { text-shadow: 5px 5px 0px #222; }
        .smol .card.shad > div { text-shadow: 3px 3px 0px #222; }
    .card.blur > div { text-shadow: 0px 0px 15px #222, 0px 0px 5px #222; }


    /************ FONTS ************/
    .card.alpha > div {
        font-family: Georgia, 'Times New Roman', Times, serif;
        font-weight: normal;
        font-size: 100px;
        margin-top: 40px;
    }
        .smol .card.alpha > div { font-size: 50px; margin-top: 10px;}
    .card.beta > div  { font-family: 'Impact'; transform: scale(1.2, 1); margin-left: 33%; }
    .card.gamma > div { font-family: 'Comic Sans MS', 'TSCU_Comic' }

    /*********** CORNERS ***********/
    .card.square { border-radius: 2px; }
    .card.round  { border-radius: 60px; border-bottom-right-radius: 5px; }
    .card.chipped  { -webkit-mask-image: radial-gradient(circle at 0 0, transparent 0, transparent 30px, #000 31px); border-radius: 15px; }
    .smol .card.chipped  { -webkit-mask-image: radial-gradient(circle at 0 0, transparent 0, transparent 15px, #000 16px); border-radius: 8px; }
    </style>

    <title>Set 2</title>
</head>

<body>

    <div id=table class=smol width=600px height=400px></div>

    <div id=indicator></div>

    <div id=controller>
        #Cards = <span id=count></span>
        <br>
        <button onclick=game.shuffle()> SHUFFLE </button>
        <br>
        <label><input type=checkbox onclick="HINTS^=true; game.clearHint(); game.hint()"> HINTS </label>
        <label><input type=checkbox checked onclick="byId('table').classList.toggle('smol');"> SMOL </label>
        <br>

        <label>
            # Dimensies:
        <select id=selector>
            <option value=1>1</option>
            <option value=2>2</option>
            <option value=3>3</option>
            <option selected value=4>4</option>
            <option value=5>5</option>
        </select>
        </label>
    </div>

</body>

<script>

    ///////////////////////////////////////////////////////// USEFUL SMOL FUNCTIONS
    var byId = id => document.getElementById(id);
    var makeElem = tag => document.createElement(tag);
    var removeChildren = x => { while (x.lastChild) x.removeChild(x.lastChild) };
    var addClass = (e, c) => { if (c!=undefined) e.classList.add(c); }

    /////////////////////////// GRACIOUSLY NABBED FROM STACKOVERFLOW
    function shuffle(a) {
        let i = a.length;
        while (i) {
            let j = Math.floor(Math.random() * i);
            i--;
            let t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
        return a;
    }

    function makeTuples(dims, depth){
        if (dims < 1 || depth < 1) throw 'ERROR: You idiot!!!!!';

        let tuples = [];
        // The "First iteration" of the loop is different!!!!
        for( let j = 0; j < depth; j++)
            tuples.push([j]);

        for (let dim = 1; dim < dims; dim++){
            let oldTuples = tuples;
            tuples = [];
            for( let i=0; i < oldTuples.length; i++ ){
                let oldTuple = oldTuples[i];
                for( let j=0; j < depth; j++ )
                    tuples.push([...oldTuple, j]);
            }
        }
        return tuples;
    }


    class Card {
        constructor(props){
            this.props = props;
            this.elem = undefined;
        }

        element(render, select) {
            let elem = this.elem = makeElem('div');
            elem.className = 'card';

            render(elem, this.props);

            elem.addEventListener( 'click', ()=>select(this) );

            return elem;
        }
    }

    class Game {
        constructor(dims, depth, render){
            // Constructs a game of Set with (dims) properties, each of which can be one of (depth) different values.
            // This means there will be (depth)^(dims) different cards, and each set consists of (depth) cards.
            if (dims < 1 || depth < 1) throw 'Error: you fucking idiot';
            this.dims = dims;
            this.depth = depth;
            this.render_card = render || function(div, props){
                // default card rendering function
                let [a, b, c, d, e] = props;
                let text = makeElem('div');
                text.innerText = NUMBERS[a];
                div.appendChild(text);
                if (b != undefined) addClass(div, COLOURS[b]);
                if (c != undefined) addClass(div, EFFECTS[c]);
                if (d != undefined) addClass(div, FONTS[d]);
                if (e != undefined) addClass(div, CORNERS[e]);
            };

            this.rendered = false;
            this.selected = [];
            this.build();
        }

        build(){
            //// Construct the set of all possible tuples!
            // i.e. tuples = F_depth ^ num
            let tuples = makeTuples(this.dims, this.depth);
            this.cards = tuples.map(t => new Card(t));
        }

        getCard(props){
            //// Gets a card by its properties.
            if (props.length != this.dims) throw 'Error: Insufficient number of properties';
            // if props = [p0, p1, p2, ... pn]
            // then index = d^n * p0 + d^n-1 * p1 + ... + pn
            // this relies on the order in which the cards are generated
            let index = props.reduce( (i, p) => p + this.depth * i);
            return this.cards[index];
        }
        

        select(card) {
            this.clearHint();

            let i = this.selected.indexOf(card);
            /// CARD IS ALREADY SELECTED: UNSELECT
            if (i != -1) {
                this.selected.splice(i, 1);
                card.elem.classList.remove('selected');
                indicator.className = '';

            } else {
                /// ALREADY (DEPTH) CARDS SELECTED: REMOVE THE OLDEST ONE FIRST
                if (this.selected.length == this.depth) {
                    this.selected[0].elem.classList.remove('selected');
                    this.selected = this.selected.slice(1);
                }
                card.elem.classList.add('selected');
                this.selected.push(card);
            }

            let l = this.selected.length;
            // ooh this one depends on how many points uniquely define a "line"
            if ( l == this.depth - 1 )
                this.hint();
            else if ( l == this.depth )
                this.check();
        }

        check() {
            if (this.depth == 3){
                let [A, B, C] = this.selected;
                var set = true;
                for (let i = 0; i < this.dims && set; i++ ){
                    let [a, b, c] = [A.props[i], B.props[i], C.props[i]];
                    // All properties are identical
                    let subset = ( a == b && b == c );
                    // OR: All properties are different
                    subset = subset || ( a != b && b != c && a != c );
                    // Sione Janssen Whiteman
                    set &= subset;
                }

            } else if (this.depth == 4){
                let [A, B, C, D] = this.selected;
                var set = true;
                for (let i = 0; i < this.dims && set; i++){
                    let [a, b, c, d] = [A.props[i], B.props[i], C.props[i], D.props[i]];
                    // Properties are two pairs of identical values
                    let subset = (a == b && c == d || a == c && b == d || a == d && b == c)
                    // OR: all properties different
                    subset = subset || a != b && a != c & a != d && b != c && b != d && c != d;
                    set &= subset;
                }
            }

            indicator.className = set ? 'good' : 'bad';
        }
        
        extrapolate(values) {
            // Uses (depth-1) values to extrapolate what the final value should be.
            if (this.depth == 3) {
                let [a, b] = values;
                if (a == b) return a;
                return 3 - (a + b);

            } else if (this.depth == 4) {
                let [a, b, c] = values;
                if (a == b) return c;
                if (a == c) return b;
                if (b == c) return a;
                // None of the previous conditions were met ⇒ {a, b, c} are all different values.
                // Therefor the number (d) we're looking for is the missing fourth value, so that {a, b, c, d} = {0, 1, 2, 3}
                // So: (a + b + c + d) = (0 + 1 + 2 + 3) = 6
                // ⇒ 6 - (a + b + c) = d
                return 6 - (a + b + c);
            }
        }

        clearHint() {
            //// Removes the "hint" effect from the hinted card.
            if (this.hintCard) this.hintCard.elem.classList.remove('hint');
        }

        hint() {
            if (!HINTS || this.selected.length < this.depth-1) return;

            let props = [];
            for (let i = 0; i < this.dims; i++){
                let selectedProps = this.selected.map(A => A.props[i]);
                props.push( this.extrapolate(selectedProps) );
            }
            this.hintCard = this.getCard(props);
            this.hintCard.elem.classList.add('hint');
            // set the callback to clear this hint
        }

        render() {
            for (let card of this.cards) {
                card.element(this.render_card, this.select.bind(this));
            }
        }

        activate() {
            if(!this.rendered) this.render();

            // Clear the table
            let table = byId('table');
            removeChildren(table);
            // Clear the indicator
            indicator.className = '';

            // Put our cards on (all?)
            for (let card of this.cards) table.appendChild(card.elem);

            byId('count').innerHTML = this.cards.length + ' = ' + this.depth + '<sup>' + this.dims + '</sup>';
        }

        shuffle() {
            let table = byId('table');
            removeChildren(table);
            for (let card of shuffle(this.cards.slice())) table.appendChild(card.elem);
        }
    }

    var indicator = byId('indicator');
    var HINTS = false;

    var NUMBERS = [1, 2, 3, 4]
    var COLOURS = ['red', 'green', 'blue', 'yellow']
    var EFFECTS = [undefined, 'line', 'shad', 'blur']
    var FONTS   = [undefined, 'alpha', 'beta', 'gamma']
    var CORNERS = ['square', undefined, 'round', 'chipped'];

    let games = [new Game(1, 3), new Game(2, 3), new Game(3, 3), new Game(4, 3), new Game(5, 3)];
    game = new Game(5, 4);
    game.activate();

    let selector = byId('selector');
    selector.addEventListener( 'change', () => { game = games[selector.value-1]; game.activate() } )

</script>

